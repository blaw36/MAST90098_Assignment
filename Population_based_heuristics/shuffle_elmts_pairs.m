%% shuffle_elmts_pairs
% pairwise at a time, for now
% keep a log of:
    % the job cost of shuffled pair
    % the machine # of shuffled pair
% See if we can improve this to run in batch! (ie on a matrix)
% See if we can input # of shuffles (run as a loop, how to efficiently keep
% track of cost changes?)

function [gene_array, costs_shuffled, machines_shuffled] = ...
    shuffle_elmts_pairs(gene_array, num_machines, num_jobs, jobs_array_aug)

% Randomly select first job to shuffle
% Grab first element
j1 = randi(num_jobs,1,1);
machines_shuffled(1) = gene_array(j1);

% Select a different (non-empty) machine to the first job, and select a 
% second job from there. First machine guaranteed to not be empty is it was
% generated by a job selection (which has been assigned a machine).
remaining_machines = [1:(machines_shuffled(1)-1),...
    (machines_shuffled(1)+1):num_machines];
if length(remaining_machines) > 1
    machines_shuffled(2) = randsample(remaining_machines,1);
elseif length(remaining_machines) == 1
    machines_shuffled(2) = remaining_machines;
% elseif length(remaining_machines) == 0
%     do something else
end

m2_elements = find(gene_array == machines_shuffled(2));
% Re-sample until one is found (lazy - fix this to use machine_costs array 
% instead!) % If there are no other non-empty machine, need to shuffle into
% an empty machine. Code that in
while isempty(m2_elements)
    machines_shuffled(2) = randsample([1:(machines_shuffled(1)-1),...
    (machines_shuffled(1)+1):num_machines],1);
    m2_elements = find(gene_array == machines_shuffled(2));
end

if length(m2_elements) == 1
    % If only one element, no need for random sample
    j2 = m2_elements;
else
    j2 = randsample(m2_elements,1);
end

% Do the swap
gene_array(j2) = machines_shuffled(1);
gene_array(j1) = machines_shuffled(2);

if nargin == 3
    % if no jobs_array, don't return costs of shuffled (save some time)
    costs_shuffled = [];
    return
end

costs_shuffled(1) = jobs_array_aug(j1);
costs_shuffled(2) = jobs_array_aug(j2);

end
