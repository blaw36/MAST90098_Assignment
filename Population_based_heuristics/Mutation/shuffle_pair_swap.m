%% shuffle_pair_swap
% pairwise at a time, for now
% keep a log of:
    % the job cost of shuffled pair
    % the machine # of shuffled pair
% See if we can improve this to run in batch! (ie on a matrix)
% See if we can input # of shuffles (run as a loop, how to efficiently keep
% track of cost changes?)

function [indiv_array, costs_shuffled, machines_shuffled] = ...
    shuffle_pair_swap(indiv_array, num_machines, num_jobs, jobs_array_aug)

% Randomly select first job to shuffle
% Grab first element
j1 = randi(num_jobs,1,1);
machines_shuffled(1) = indiv_array(j1);

% Select a different (non-empty) machine to the first job, and select a 
% second job from there. First machine guaranteed to not be empty is it was
% generated by a job selection (which has been assigned a machine).
remaining_machines = [1:(machines_shuffled(1)-1),...
    (machines_shuffled(1)+1):num_machines];
remaining_machine_length = length(remaining_machines);
if remaining_machine_length > 1
%     machines_shuffled(2) = randsample(remaining_machines,1);
%randsample is slow so randomly find index from 1:length(array) and then
%index based on the random number
    machines_shuffled(2) = remaining_machines( ...
        randi(remaining_machine_length));
elseif length(remaining_machines) == 1
    machines_shuffled(2) = remaining_machines;
% elseif length(remaining_machines) == 0
%     do something else
end

m2_elements = find(indiv_array == machines_shuffled(2));
% Re-sample until one is found (lazy - fix this to use machine_costs array 
% instead!) % If there are no other non-empty machine, need to shuffle into
% an empty machine. Code that in
while isempty(m2_elements)
    machines_shuffled(2) = remaining_machines( ...
        randi(remaining_machine_length));
    m2_elements = find(indiv_array == machines_shuffled(2));
end

if length(m2_elements) == 1
    % If only one element, no need for random sample
    j2 = m2_elements;
else
    j2 = m2_elements(randi(length(m2_elements)));
end

% Do the swap
indiv_array(j2) = machines_shuffled(1);
indiv_array(j1) = machines_shuffled(2);

if nargin == 3
    % if no jobs_array, don't return costs of shuffled (save some time)
    costs_shuffled = [];
    return
end

% Format output to be consistent with other mutation operations
machines_shuffled(2,:) = [machines_shuffled(2), machines_shuffled(1)];

costs_shuffled = [jobs_array_aug(j1); jobs_array_aug(j2)];

end
